"""
SQL functions reference lists:
https://web.archive.org/web/20130407175746/https://www.gaia-gis.it/gaia-sins/spatialite-sql-4.0.0.html
https://www.gaia-gis.it/gaia-sins/spatialite-sql-4.2.1.html
"""
<<<<<<< HEAD
=======
import re
import sys

>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
from django.contrib.gis.db.backends.base.operations import (
    BaseSpatialOperations,
)
from django.contrib.gis.db.backends.spatialite.adapter import SpatiaLiteAdapter
from django.contrib.gis.db.backends.utils import SpatialOperator
from django.contrib.gis.db.models import aggregates
<<<<<<< HEAD
from django.contrib.gis.geos.geometry import GEOSGeometry, GEOSGeometryBase
from django.contrib.gis.geos.prototypes.io import wkb_r, wkt_r
from django.contrib.gis.measure import Distance
from django.core.exceptions import ImproperlyConfigured
from django.db.backends.sqlite3.operations import DatabaseOperations
from django.utils.functional import cached_property
from django.utils.version import get_version_tuple


class SpatialiteNullCheckOperator(SpatialOperator):
    def as_sql(self, connection, lookup, template_params, sql_params):
        sql, params = super().as_sql(connection, lookup, template_params, sql_params)
        return '%s > 0' % sql, params
=======
from django.contrib.gis.geometry.backend import Geometry
from django.contrib.gis.measure import Distance
from django.core.exceptions import ImproperlyConfigured
from django.db.backends.sqlite3.operations import DatabaseOperations
from django.utils import six
from django.utils.functional import cached_property


class SpatiaLiteDistanceOperator(SpatialOperator):
    def as_sql(self, connection, lookup, template_params, sql_params):
        if lookup.lhs.output_field.geodetic(connection):
            # SpatiaLite returns NULL instead of zero on geodetic coordinates
            sql_template = 'COALESCE(%(func)s(%(lhs)s, %(rhs)s, %%s), 0) %(op)s %(value)s'
            template_params.update({
                'op': self.op,
                'func': connection.ops.spatial_function_name('Distance'),
            })
            sql_params.insert(1, len(lookup.rhs) == 3 and lookup.rhs[-1] == 'spheroid')
            return sql_template % template_params, sql_params
        return super(SpatiaLiteDistanceOperator, self).as_sql(connection, lookup, template_params, sql_params)
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61


class SpatiaLiteOperations(BaseSpatialOperations, DatabaseOperations):
    name = 'spatialite'
    spatialite = True
<<<<<<< HEAD

    Adapter = SpatiaLiteAdapter

    collect = 'Collect'
    extent = 'Extent'
    makeline = 'MakeLine'
    unionagg = 'GUnion'

    from_text = 'GeomFromText'

    gis_operators = {
        # Binary predicates
        'equals': SpatialiteNullCheckOperator(func='Equals'),
        'disjoint': SpatialiteNullCheckOperator(func='Disjoint'),
        'touches': SpatialiteNullCheckOperator(func='Touches'),
        'crosses': SpatialiteNullCheckOperator(func='Crosses'),
        'within': SpatialiteNullCheckOperator(func='Within'),
        'overlaps': SpatialiteNullCheckOperator(func='Overlaps'),
        'contains': SpatialiteNullCheckOperator(func='Contains'),
        'intersects': SpatialiteNullCheckOperator(func='Intersects'),
        'relate': SpatialiteNullCheckOperator(func='Relate'),
=======
    version_regex = re.compile(r'^(?P<major>\d)\.(?P<minor1>\d)\.(?P<minor2>\d+)')

    Adapter = SpatiaLiteAdapter

    area = 'Area'
    centroid = 'Centroid'
    collect = 'Collect'
    contained = 'MbrWithin'
    difference = 'Difference'
    distance = 'Distance'
    envelope = 'Envelope'
    extent = 'Extent'
    geojson = 'AsGeoJSON'
    gml = 'AsGML'
    intersection = 'Intersection'
    kml = 'AsKML'
    length = 'GLength'  # OpenGis defines Length, but this conflicts with an SQLite reserved keyword
    makeline = 'MakeLine'
    num_geom = 'NumGeometries'
    num_points = 'NumPoints'
    point_on_surface = 'PointOnSurface'
    scale = 'ScaleCoords'
    svg = 'AsSVG'
    sym_difference = 'SymDifference'
    transform = 'Transform'
    translate = 'ShiftCoords'
    union = 'GUnion'  # OpenGis defines Union, but this conflicts with an SQLite reserved keyword
    unionagg = 'GUnion'

    from_text = 'GeomFromText'
    from_wkb = 'GeomFromWKB'
    select = 'AsText(%s)'

    gis_operators = {
        # Unary predicates
        'isvalid': SpatialOperator(func='IsValid'),
        # Binary predicates
        'equals': SpatialOperator(func='Equals'),
        'disjoint': SpatialOperator(func='Disjoint'),
        'touches': SpatialOperator(func='Touches'),
        'crosses': SpatialOperator(func='Crosses'),
        'within': SpatialOperator(func='Within'),
        'overlaps': SpatialOperator(func='Overlaps'),
        'contains': SpatialOperator(func='Contains'),
        'intersects': SpatialOperator(func='Intersects'),
        'relate': SpatialOperator(func='Relate'),
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        # Returns true if B's bounding box completely contains A's bounding box.
        'contained': SpatialOperator(func='MbrWithin'),
        # Returns true if A's bounding box completely contains B's bounding box.
        'bbcontains': SpatialOperator(func='MbrContains'),
        # Returns true if A's bounding box overlaps B's bounding box.
        'bboverlaps': SpatialOperator(func='MbrOverlaps'),
        # These are implemented here as synonyms for Equals
<<<<<<< HEAD
        'same_as': SpatialiteNullCheckOperator(func='Equals'),
        'exact': SpatialiteNullCheckOperator(func='Equals'),
        # Distance predicates
        'dwithin': SpatialOperator(func='PtDistWithin'),
=======
        'same_as': SpatialOperator(func='Equals'),
        'exact': SpatialOperator(func='Equals'),
        # Distance predicates
        'dwithin': SpatialOperator(func='PtDistWithin'),
        'distance_gt': SpatiaLiteDistanceOperator(func='Distance', op='>'),
        'distance_gte': SpatiaLiteDistanceOperator(func='Distance', op='>='),
        'distance_lt': SpatiaLiteDistanceOperator(func='Distance', op='<'),
        'distance_lte': SpatiaLiteDistanceOperator(func='Distance', op='<='),
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
    }

    disallowed_aggregates = (aggregates.Extent3D,)

    @cached_property
<<<<<<< HEAD
    def select(self):
        return 'CAST (AsEWKB(%s) AS BLOB)' if self.spatial_version >= (4, 3, 0) else 'AsText(%s)'

    function_names = {
        'Length': 'ST_Length',
        'LineLocatePoint': 'ST_Line_Locate_Point',
        'NumPoints': 'ST_NPoints',
        'Reverse': 'ST_Reverse',
        'Scale': 'ScaleCoords',
        'Translate': 'ST_Translate',
        'Union': 'ST_Union',
    }
=======
    def function_names(self):
        return {
            'Length': 'ST_Length',
            'Reverse': 'ST_Reverse',
            'Scale': 'ScaleCoords',
            'Translate': 'ST_Translate',
            'Union': 'ST_Union',
        }
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61

    @cached_property
    def unsupported_functions(self):
        unsupported = {'BoundingCircle', 'ForceRHR', 'MemSize'}
        if not self.lwgeom_version():
<<<<<<< HEAD
            unsupported |= {'Azimuth', 'GeoHash', 'IsValid', 'MakeValid'}
=======
            unsupported |= {'GeoHash', 'IsValid', 'MakeValid'}
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        return unsupported

    @cached_property
    def spatial_version(self):
        """Determine the version of the SpatiaLite library."""
        try:
            version = self.spatialite_version_tuple()[1:]
<<<<<<< HEAD
        except Exception as exc:
            raise ImproperlyConfigured(
                'Cannot determine the SpatiaLite version for the "%s" database. '
                'Was the SpatiaLite initialization SQL loaded on this database?' % (
                    self.connection.settings_dict['NAME'],
                )
            ) from exc
=======
        except Exception as msg:
            new_msg = (
                'Cannot determine the SpatiaLite version for the "%s" '
                'database (error was "%s").  Was the SpatiaLite initialization '
                'SQL loaded on this database?') % (self.connection.settings_dict['NAME'], msg)
            six.reraise(ImproperlyConfigured, ImproperlyConfigured(new_msg), sys.exc_info()[2])
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        if version < (4, 0, 0):
            raise ImproperlyConfigured('GeoDjango only supports SpatiaLite versions 4.0.0 and above.')
        return version

<<<<<<< HEAD
    def convert_extent(self, box):
=======
    def convert_extent(self, box, srid):
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        """
        Convert the polygon data received from SpatiaLite to min/max values.
        """
        if box is None:
            return None
<<<<<<< HEAD
        shell = GEOSGeometry(box).shell
=======
        shell = Geometry(box, srid).shell
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        xmin, ymin = shell[0][:2]
        xmax, ymax = shell[2][:2]
        return (xmin, ymin, xmax, ymax)

    def geo_db_type(self, f):
        """
<<<<<<< HEAD
        Return None because geometry columns are added via the
=======
        Returns None because geometry columns are added via the
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        `AddGeometryColumn` stored procedure on SpatiaLite.
        """
        return None

<<<<<<< HEAD
    def get_distance(self, f, value, lookup_type):
        """
        Return the distance parameters for the given geometry field,
=======
    def get_distance(self, f, value, lookup_type, **kwargs):
        """
        Returns the distance parameters for the given geometry field,
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        lookup value, and lookup type.
        """
        if not value:
            return []
        value = value[0]
        if isinstance(value, Distance):
            if f.geodetic(self.connection):
                if lookup_type == 'dwithin':
                    raise ValueError(
                        'Only numeric values of degree units are allowed on '
                        'geographic DWithin queries.'
                    )
                dist_param = value.m
            else:
                dist_param = getattr(value, Distance.unit_attname(f.units_name(self.connection)))
        else:
            dist_param = value
        return [dist_param]

<<<<<<< HEAD
=======
    def get_geom_placeholder(self, f, value, compiler):
        """
        Provides a proper substitution value for Geometries that are not in the
        SRID of the field.  Specifically, this routine will substitute in the
        Transform() and GeomFromText() function call(s).
        """
        def transform_value(value, srid):
            return not (value is None or value.srid == srid)
        if hasattr(value, 'as_sql'):
            if transform_value(value, f.srid):
                placeholder = '%s(%%s, %s)' % (self.transform, f.srid)
            else:
                placeholder = '%s'
            # No geometry value used for F expression, substitute in
            # the column name instead.
            sql, _ = compiler.compile(value)
            return placeholder % sql
        else:
            if transform_value(value, f.srid):
                # Adding Transform() to the SQL placeholder.
                return '%s(%s(%%s,%s), %s)' % (self.transform, self.from_text, value.srid, f.srid)
            else:
                return '%s(%%s,%s)' % (self.from_text, f.srid)

>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
    def _get_spatialite_func(self, func):
        """
        Helper routine for calling SpatiaLite functions and returning
        their result.
        Any error occurring in this method should be handled by the caller.
        """
        cursor = self.connection._cursor()
        try:
            cursor.execute('SELECT %s' % func)
            row = cursor.fetchone()
        finally:
            cursor.close()
        return row[0]

    def geos_version(self):
<<<<<<< HEAD
        "Return the version of GEOS used by SpatiaLite as a string."
        return self._get_spatialite_func('geos_version()')

    def proj4_version(self):
        "Return the version of the PROJ.4 library used by SpatiaLite."
=======
        "Returns the version of GEOS used by SpatiaLite as a string."
        return self._get_spatialite_func('geos_version()')

    def proj4_version(self):
        "Returns the version of the PROJ.4 library used by SpatiaLite."
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        return self._get_spatialite_func('proj4_version()')

    def lwgeom_version(self):
        """Return the version of LWGEOM library used by SpatiaLite."""
        return self._get_spatialite_func('lwgeom_version()')

    def spatialite_version(self):
<<<<<<< HEAD
        "Return the SpatiaLite library version as a string."
=======
        "Returns the SpatiaLite library version as a string."
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        return self._get_spatialite_func('spatialite_version()')

    def spatialite_version_tuple(self):
        """
<<<<<<< HEAD
        Return the SpatiaLite version as a tuple (version string, major,
        minor, subminor).
        """
        version = self.spatialite_version()
        return (version,) + get_version_tuple(version)

    def spatial_aggregate_name(self, agg_name):
        """
        Return the spatial aggregate SQL template and function for the
=======
        Returns the SpatiaLite version as a tuple (version string, major,
        minor, subminor).
        """
        version = self.spatialite_version()

        m = self.version_regex.match(version)
        if m:
            major = int(m.group('major'))
            minor1 = int(m.group('minor1'))
            minor2 = int(m.group('minor2'))
        else:
            raise Exception('Could not parse SpatiaLite version string: %s' % version)

        return (version, major, minor1, minor2)

    def spatial_aggregate_name(self, agg_name):
        """
        Returns the spatial aggregate SQL template and function for the
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        given Aggregate instance.
        """
        agg_name = 'unionagg' if agg_name.lower() == 'union' else agg_name.lower()
        return getattr(self, agg_name)

    # Routines for getting the OGC-compliant models.
    def geometry_columns(self):
        from django.contrib.gis.db.backends.spatialite.models import SpatialiteGeometryColumns
        return SpatialiteGeometryColumns

    def spatial_ref_sys(self):
        from django.contrib.gis.db.backends.spatialite.models import SpatialiteSpatialRefSys
        return SpatialiteSpatialRefSys

<<<<<<< HEAD
    def get_geometry_converter(self, expression):
        geom_class = expression.output_field.geom_class
        if self.spatial_version >= (4, 3, 0):
            read = wkb_r().read

            def converter(value, expression, connection):
                return None if value is None else GEOSGeometryBase(read(value), geom_class)
        else:
            read = wkt_r().read
            srid = expression.output_field.srid
            if srid == -1:
                srid = None

            def converter(value, expression, connection):
                if value is not None:
                    geom = GEOSGeometryBase(read(value), geom_class)
                    if srid:
                        geom.srid = srid
                    return geom
        return converter
=======
    def get_db_converters(self, expression):
        converters = super(SpatiaLiteOperations, self).get_db_converters(expression)
        if hasattr(expression.output_field, 'geom_type'):
            converters.append(self.convert_geometry)
        return converters

    def convert_geometry(self, value, expression, connection, context):
        if value:
            value = Geometry(value)
            if 'transformed_srid' in context:
                value.srid = context['transformed_srid']
        return value
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
