from ctypes import byref, c_int
from datetime import date, datetime, time

from django.contrib.gis.gdal.base import GDALBase
from django.contrib.gis.gdal.error import GDALException
from django.contrib.gis.gdal.prototypes import ds as capi
from django.utils.encoding import force_text


# For more information, see the OGR C API source code:
#  http://www.gdal.org/ogr__api_8h.html
#
# The OGR_Fld_* routines are relevant here.
class Field(GDALBase):
    """
<<<<<<< HEAD
    Wrap an OGR Field. Needs to be instantiated from a Feature object.
=======
    This class wraps an OGR Field, and needs to be instantiated
    from a Feature object.
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
    """

    def __init__(self, feat, index):
        """
<<<<<<< HEAD
        Initialize on the feature object and the integer index of
=======
        Initializes on the feature object and the integer index of
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        the field within the feature.
        """
        # Setting the feature pointer and index.
        self._feat = feat
        self._index = index

        # Getting the pointer for this field.
        fld_ptr = capi.get_feat_field_defn(feat.ptr, index)
        if not fld_ptr:
            raise GDALException('Cannot create OGR Field, invalid pointer given.')
        self.ptr = fld_ptr

        # Setting the class depending upon the OGR Field Type (OFT)
        self.__class__ = OGRFieldTypes[self.type]

        # OFTReal with no precision should be an OFTInteger.
        if isinstance(self, OFTReal) and self.precision == 0:
            self.__class__ = OFTInteger
            self._double = True

    def __str__(self):
<<<<<<< HEAD
        "Return the string representation of the Field."
=======
        "Returns the string representation of the Field."
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        return str(self.value).strip()

    # #### Field Methods ####
    def as_double(self):
<<<<<<< HEAD
        "Retrieve the Field's value as a double (float)."
        return capi.get_field_as_double(self._feat.ptr, self._index)

    def as_int(self, is_64=False):
        "Retrieve the Field's value as an integer."
=======
        "Retrieves the Field's value as a double (float)."
        return capi.get_field_as_double(self._feat.ptr, self._index)

    def as_int(self, is_64=False):
        "Retrieves the Field's value as an integer."
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        if is_64:
            return capi.get_field_as_integer64(self._feat.ptr, self._index)
        else:
            return capi.get_field_as_integer(self._feat.ptr, self._index)

    def as_string(self):
<<<<<<< HEAD
        "Retrieve the Field's value as a string."
=======
        "Retrieves the Field's value as a string."
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        string = capi.get_field_as_string(self._feat.ptr, self._index)
        return force_text(string, encoding=self._feat.encoding, strings_only=True)

    def as_datetime(self):
<<<<<<< HEAD
        "Retrieve the Field's value as a tuple of date & time components."
=======
        "Retrieves the Field's value as a tuple of date & time components."
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        yy, mm, dd, hh, mn, ss, tz = [c_int() for i in range(7)]
        status = capi.get_field_as_datetime(
            self._feat.ptr, self._index, byref(yy), byref(mm), byref(dd),
            byref(hh), byref(mn), byref(ss), byref(tz))
        if status:
            return (yy, mm, dd, hh, mn, ss, tz)
        else:
            raise GDALException('Unable to retrieve date & time information from the field.')

    # #### Field Properties ####
    @property
    def name(self):
<<<<<<< HEAD
        "Return the name of this Field."
=======
        "Returns the name of this Field."
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        name = capi.get_field_name(self.ptr)
        return force_text(name, encoding=self._feat.encoding, strings_only=True)

    @property
    def precision(self):
<<<<<<< HEAD
        "Return the precision of this Field."
=======
        "Returns the precision of this Field."
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        return capi.get_field_precision(self.ptr)

    @property
    def type(self):
<<<<<<< HEAD
        "Return the OGR type of this Field."
=======
        "Returns the OGR type of this Field."
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        return capi.get_field_type(self.ptr)

    @property
    def type_name(self):
        "Return the OGR field type name for this Field."
        return capi.get_field_type_name(self.type)

    @property
    def value(self):
<<<<<<< HEAD
        "Return the value of this Field."
=======
        "Returns the value of this Field."
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        # Default is to get the field as a string.
        return self.as_string()

    @property
    def width(self):
<<<<<<< HEAD
        "Return the width of this Field."
=======
        "Returns the width of this Field."
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        return capi.get_field_width(self.ptr)


# ### The Field sub-classes for each OGR Field type. ###
class OFTInteger(Field):
    _double = False
    _bit64 = False

    @property
    def value(self):
<<<<<<< HEAD
        "Return an integer contained in this field."
=======
        "Returns an integer contained in this field."
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        if self._double:
            # If this is really from an OFTReal field with no precision,
            # read as a double and cast as Python int (to prevent overflow).
            return int(self.as_double())
        else:
            return self.as_int(self._bit64)

    @property
    def type(self):
        """
        GDAL uses OFTReals to represent OFTIntegers in created
        shapefiles -- forcing the type here since the underlying field
        type may actually be OFTReal.
        """
        return 0


class OFTReal(Field):
    @property
    def value(self):
<<<<<<< HEAD
        "Return a float contained in this field."
=======
        "Returns a float contained in this field."
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        return self.as_double()


# String & Binary fields, just subclasses
class OFTString(Field):
    pass


class OFTWideString(Field):
    pass


class OFTBinary(Field):
    pass


# OFTDate, OFTTime, OFTDateTime fields.
class OFTDate(Field):
    @property
    def value(self):
<<<<<<< HEAD
        "Return a Python `date` object for the OFTDate field."
=======
        "Returns a Python `date` object for the OFTDate field."
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        try:
            yy, mm, dd, hh, mn, ss, tz = self.as_datetime()
            return date(yy.value, mm.value, dd.value)
        except (ValueError, GDALException):
            return None


class OFTDateTime(Field):
    @property
    def value(self):
<<<<<<< HEAD
        "Return a Python `datetime` object for this OFTDateTime field."
=======
        "Returns a Python `datetime` object for this OFTDateTime field."
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        # TODO: Adapt timezone information.
        #  See http://lists.osgeo.org/pipermail/gdal-dev/2006-February/007990.html
        #  The `tz` variable has values of: 0=unknown, 1=localtime (ambiguous),
        #  100=GMT, 104=GMT+1, 80=GMT-5, etc.
        try:
            yy, mm, dd, hh, mn, ss, tz = self.as_datetime()
            return datetime(yy.value, mm.value, dd.value, hh.value, mn.value, ss.value)
        except (ValueError, GDALException):
            return None


class OFTTime(Field):
    @property
    def value(self):
<<<<<<< HEAD
        "Return a Python `time` object for this OFTTime field."
=======
        "Returns a Python `time` object for this OFTTime field."
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        try:
            yy, mm, dd, hh, mn, ss, tz = self.as_datetime()
            return time(hh.value, mn.value, ss.value)
        except (ValueError, GDALException):
            return None


class OFTInteger64(OFTInteger):
    _bit64 = True


# List fields are also just subclasses
class OFTIntegerList(Field):
    pass


class OFTRealList(Field):
    pass


class OFTStringList(Field):
    pass


class OFTWideStringList(Field):
    pass


class OFTInteger64List(Field):
    pass


# Class mapping dictionary for OFT Types and reverse mapping.
OGRFieldTypes = {
    0: OFTInteger,
    1: OFTIntegerList,
    2: OFTReal,
    3: OFTRealList,
    4: OFTString,
    5: OFTStringList,
    6: OFTWideString,
    7: OFTWideStringList,
    8: OFTBinary,
    9: OFTDate,
    10: OFTTime,
    11: OFTDateTime,
    # New 64-bit integer types in GDAL 2
    12: OFTInteger64,
    13: OFTInteger64List,
}
ROGRFieldTypes = {cls: num for num, cls in OGRFieldTypes.items()}
