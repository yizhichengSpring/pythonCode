"""
 The OGRGeometry is a wrapper for using the OGR Geometry class
 (see http://www.gdal.org/classOGRGeometry.html).  OGRGeometry
 may be instantiated when reading geometries from OGR Data Sources
 (e.g. SHP files), or when given OGC WKT (a string).

 While the 'full' API is not present yet, the API is "pythonic" unlike
 the traditional and "next-generation" OGR Python bindings.  One major
 advantage OGR Geometries have over their GEOS counterparts is support
 for spatial reference systems and their transformation.

 Example:
  >>> from django.contrib.gis.gdal import OGRGeometry, OGRGeomType, SpatialReference
  >>> wkt1, wkt2 = 'POINT(-90 30)', 'POLYGON((0 0, 5 0, 5 5, 0 5)'
  >>> pnt = OGRGeometry(wkt1)
  >>> print(pnt)
  POINT (-90 30)
  >>> mpnt = OGRGeometry(OGRGeomType('MultiPoint'), SpatialReference('WGS84'))
  >>> mpnt.add(wkt1)
  >>> mpnt.add(wkt1)
  >>> print(mpnt)
  MULTIPOINT (-90 30,-90 30)
  >>> print(mpnt.srs.name)
  WGS 84
  >>> print(mpnt.srs.proj)
  +proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs
  >>> mpnt.transform(SpatialReference('NAD27'))
  >>> print(mpnt.proj)
  +proj=longlat +ellps=clrk66 +datum=NAD27 +no_defs
  >>> print(mpnt)
  MULTIPOINT (-89.999930378602485 29.999797886557641,-89.999930378602485 29.999797886557641)

  The OGRGeomType class is to make it easy to specify an OGR geometry type:
  >>> from django.contrib.gis.gdal import OGRGeomType
  >>> gt1 = OGRGeomType(3) # Using an integer for the type
  >>> gt2 = OGRGeomType('Polygon') # Using a string
  >>> gt3 = OGRGeomType('POLYGON') # It's case-insensitive
  >>> print(gt1 == 3, gt1 == 'Polygon') # Equivalence works w/non-OGRGeomType objects
  True True
"""
import sys
from binascii import a2b_hex, b2a_hex
from ctypes import byref, c_char_p, c_double, c_ubyte, c_void_p, string_at

from django.contrib.gis.gdal.base import GDALBase
from django.contrib.gis.gdal.envelope import Envelope, OGREnvelope
<<<<<<< HEAD
from django.contrib.gis.gdal.error import GDALException, SRSException
from django.contrib.gis.gdal.geomtype import OGRGeomType
from django.contrib.gis.gdal.libgdal import GDAL_VERSION
from django.contrib.gis.gdal.prototypes import geom as capi, srs as srs_api
from django.contrib.gis.gdal.srs import CoordTransform, SpatialReference
from django.contrib.gis.geometry import hex_regex, json_regex, wkt_regex
from django.utils.encoding import force_bytes
=======
from django.contrib.gis.gdal.error import (
    GDALException, OGRIndexError, SRSException,
)
from django.contrib.gis.gdal.geomtype import OGRGeomType
from django.contrib.gis.gdal.prototypes import geom as capi, srs as srs_api
from django.contrib.gis.gdal.srs import CoordTransform, SpatialReference
from django.contrib.gis.geometry.regex import hex_regex, json_regex, wkt_regex
from django.utils import six
from django.utils.encoding import force_bytes
from django.utils.six.moves import range
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61


# For more information, see the OGR C API source code:
#  http://www.gdal.org/ogr__api_8h.html
#
# The OGR_G_* routines are relevant here.
class OGRGeometry(GDALBase):
<<<<<<< HEAD
    """Encapsulate an OGR geometry."""
    destructor = capi.destroy_geom

    def __init__(self, geom_input, srs=None):
        """Initialize Geometry on either WKT or an OGR pointer as input."""
        str_instance = isinstance(geom_input, str)

        # If HEX, unpack input to a binary buffer.
        if str_instance and hex_regex.match(geom_input):
            geom_input = memoryview(a2b_hex(geom_input.upper().encode()))
=======
    "Generally encapsulates an OGR geometry."
    destructor = capi.destroy_geom

    def __init__(self, geom_input, srs=None):
        "Initializes Geometry on either WKT or an OGR pointer as input."

        str_instance = isinstance(geom_input, six.string_types)

        # If HEX, unpack input to a binary buffer.
        if str_instance and hex_regex.match(geom_input):
            geom_input = six.memoryview(a2b_hex(geom_input.upper().encode()))
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
            str_instance = False

        # Constructing the geometry,
        if str_instance:
            wkt_m = wkt_regex.match(geom_input)
            json_m = json_regex.match(geom_input)
            if wkt_m:
                if wkt_m.group('srid'):
                    # If there's EWKT, set the SRS w/value of the SRID.
                    srs = int(wkt_m.group('srid'))
                if wkt_m.group('type').upper() == 'LINEARRING':
                    # OGR_G_CreateFromWkt doesn't work with LINEARRING WKT.
                    #  See http://trac.osgeo.org/gdal/ticket/1992.
                    g = capi.create_geom(OGRGeomType(wkt_m.group('type')).num)
                    capi.import_wkt(g, byref(c_char_p(wkt_m.group('wkt').encode())))
                else:
                    g = capi.from_wkt(byref(c_char_p(wkt_m.group('wkt').encode())), None, byref(c_void_p()))
            elif json_m:
<<<<<<< HEAD
                g = self._from_json(geom_input.encode())
=======
                g = capi.from_json(geom_input.encode())
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
            else:
                # Seeing if the input is a valid short-hand string
                # (e.g., 'Point', 'POLYGON').
                OGRGeomType(geom_input)
                g = capi.create_geom(OGRGeomType(geom_input).num)
<<<<<<< HEAD
        elif isinstance(geom_input, memoryview):
=======
        elif isinstance(geom_input, six.memoryview):
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
            # WKB was passed in
            g = self._from_wkb(geom_input)
        elif isinstance(geom_input, OGRGeomType):
            # OGRGeomType was passed in, an empty geometry will be created.
            g = capi.create_geom(geom_input.num)
        elif isinstance(geom_input, self.ptr_type):
            # OGR pointer (c_void_p) was the input.
            g = geom_input
        else:
            raise GDALException('Invalid input type for OGR Geometry construction: %s' % type(geom_input))

        # Now checking the Geometry pointer before finishing initialization
        # by setting the pointer for the object.
        if not g:
<<<<<<< HEAD
            raise GDALException('Cannot create OGR Geometry from input: %s' % geom_input)
=======
            raise GDALException('Cannot create OGR Geometry from input: %s' % str(geom_input))
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        self.ptr = g

        # Assigning the SpatialReference object to the geometry, if valid.
        if srs:
            self.srs = srs

        # Setting the class depending upon the OGR Geometry Type
        self.__class__ = GEO_CLASSES[self.geom_type.num]

    # Pickle routines
    def __getstate__(self):
        srs = self.srs
        if srs:
            srs = srs.wkt
        else:
            srs = None
        return bytes(self.wkb), srs

    def __setstate__(self, state):
        wkb, srs = state
        ptr = capi.from_wkb(wkb, None, byref(c_void_p()), len(wkb))
        if not ptr:
            raise GDALException('Invalid OGRGeometry loaded from pickled state.')
        self.ptr = ptr
        self.srs = srs

    @classmethod
    def _from_wkb(cls, geom_input):
        return capi.from_wkb(bytes(geom_input), None, byref(c_void_p()), len(geom_input))

<<<<<<< HEAD
    @staticmethod
    def _from_json(geom_input):
        ptr = capi.from_json(geom_input)
        if GDAL_VERSION < (2, 0):
            has_srs = True
            try:
                capi.get_geom_srs(ptr)
            except SRSException:
                has_srs = False
            if not has_srs:
                srs = SpatialReference(4326)
                capi.assign_srs(ptr, srs.ptr)
        return ptr

    @classmethod
    def from_bbox(cls, bbox):
        "Construct a Polygon from a bounding box (4-tuple)."
=======
    @classmethod
    def from_bbox(cls, bbox):
        "Constructs a Polygon from a bounding box (4-tuple)."
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        x0, y0, x1, y1 = bbox
        return OGRGeometry('POLYGON((%s %s, %s %s, %s %s, %s %s, %s %s))' % (
            x0, y0, x0, y1, x1, y1, x1, y0, x0, y0))

<<<<<<< HEAD
    @staticmethod
    def from_json(geom_input):
        return OGRGeometry(OGRGeometry._from_json(force_bytes(geom_input)))

=======
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
    @classmethod
    def from_gml(cls, gml_string):
        return cls(capi.from_gml(force_bytes(gml_string)))

    # ### Geometry set-like operations ###
    # g = g1 | g2
    def __or__(self, other):
<<<<<<< HEAD
        "Return the union of the two geometries."
=======
        "Returns the union of the two geometries."
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        return self.union(other)

    # g = g1 & g2
    def __and__(self, other):
<<<<<<< HEAD
        "Return the intersection of this Geometry and the other."
=======
        "Returns the intersection of this Geometry and the other."
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        return self.intersection(other)

    # g = g1 - g2
    def __sub__(self, other):
        "Return the difference this Geometry and the other."
        return self.difference(other)

    # g = g1 ^ g2
    def __xor__(self, other):
        "Return the symmetric difference of this Geometry and the other."
        return self.sym_difference(other)

    def __eq__(self, other):
        "Is this Geometry equal to the other?"
        if isinstance(other, OGRGeometry):
            return self.equals(other)
        else:
            return False

<<<<<<< HEAD
=======
    def __ne__(self, other):
        "Tests for inequality."
        return not (self == other)

>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
    def __str__(self):
        "WKT is used for the string representation."
        return self.wkt

    # #### Geometry Properties ####
    @property
    def dimension(self):
<<<<<<< HEAD
        "Return 0 for points, 1 for lines, and 2 for surfaces."
        return capi.get_dims(self.ptr)

    def _get_coord_dim(self):
        "Return the coordinate dimension of the Geometry."
        return capi.get_coord_dim(self.ptr)

    def _set_coord_dim(self, dim):
        "Set the coordinate dimension of this Geometry."
=======
        "Returns 0 for points, 1 for lines, and 2 for surfaces."
        return capi.get_dims(self.ptr)

    def _get_coord_dim(self):
        "Returns the coordinate dimension of the Geometry."
        return capi.get_coord_dim(self.ptr)

    def _set_coord_dim(self, dim):
        "Sets the coordinate dimension of this Geometry."
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        if dim not in (2, 3):
            raise ValueError('Geometry dimension must be either 2 or 3')
        capi.set_coord_dim(self.ptr, dim)

    coord_dim = property(_get_coord_dim, _set_coord_dim)

    @property
    def geom_count(self):
<<<<<<< HEAD
        "Return the number of elements in this Geometry."
=======
        "The number of elements in this Geometry."
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        return capi.get_geom_count(self.ptr)

    @property
    def point_count(self):
<<<<<<< HEAD
        "Return the number of Points in this Geometry."
=======
        "Returns the number of Points in this Geometry."
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        return capi.get_point_count(self.ptr)

    @property
    def num_points(self):
        "Alias for `point_count` (same name method in GEOS API.)"
        return self.point_count

    @property
    def num_coords(self):
<<<<<<< HEAD
        "Alias for `point_count`."
=======
        "Alais for `point_count`."
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        return self.point_count

    @property
    def geom_type(self):
<<<<<<< HEAD
        "Return the Type for this Geometry."
=======
        "Returns the Type for this Geometry."
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        return OGRGeomType(capi.get_geom_type(self.ptr))

    @property
    def geom_name(self):
<<<<<<< HEAD
        "Return the Name of this Geometry."
=======
        "Returns the Name of this Geometry."
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        return capi.get_geom_name(self.ptr)

    @property
    def area(self):
<<<<<<< HEAD
        "Return the area for a LinearRing, Polygon, or MultiPolygon; 0 otherwise."
=======
        "Returns the area for a LinearRing, Polygon, or MultiPolygon; 0 otherwise."
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        return capi.get_area(self.ptr)

    @property
    def envelope(self):
<<<<<<< HEAD
        "Return the envelope for this Geometry."
=======
        "Returns the envelope for this Geometry."
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        # TODO: Fix Envelope() for Point geometries.
        return Envelope(capi.get_envelope(self.ptr, byref(OGREnvelope())))

    @property
    def empty(self):
        return capi.is_empty(self.ptr)

    @property
    def extent(self):
<<<<<<< HEAD
        "Return the envelope as a 4-tuple, instead of as an Envelope object."
=======
        "Returns the envelope as a 4-tuple, instead of as an Envelope object."
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        return self.envelope.tuple

    # #### SpatialReference-related Properties ####

    # The SRS property
    def _get_srs(self):
<<<<<<< HEAD
        "Return the Spatial Reference for this Geometry."
=======
        "Returns the Spatial Reference for this Geometry."
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        try:
            srs_ptr = capi.get_geom_srs(self.ptr)
            return SpatialReference(srs_api.clone_srs(srs_ptr))
        except SRSException:
            return None

    def _set_srs(self, srs):
<<<<<<< HEAD
        "Set the SpatialReference for this geometry."
=======
        "Sets the SpatialReference for this geometry."
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        # Do not have to clone the `SpatialReference` object pointer because
        # when it is assigned to this `OGRGeometry` it's internal OGR
        # reference count is incremented, and will likewise be released
        # (decremented) when this geometry's destructor is called.
        if isinstance(srs, SpatialReference):
            srs_ptr = srs.ptr
<<<<<<< HEAD
        elif isinstance(srs, (int, str)):
=======
        elif isinstance(srs, six.integer_types + six.string_types):
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
            sr = SpatialReference(srs)
            srs_ptr = sr.ptr
        elif srs is None:
            srs_ptr = None
        else:
            raise TypeError('Cannot assign spatial reference with object of type: %s' % type(srs))
        capi.assign_srs(self.ptr, srs_ptr)

    srs = property(_get_srs, _set_srs)

    # The SRID property
    def _get_srid(self):
        srs = self.srs
        if srs:
            return srs.srid
        return None

    def _set_srid(self, srid):
<<<<<<< HEAD
        if isinstance(srid, int) or srid is None:
=======
        if isinstance(srid, six.integer_types) or srid is None:
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
            self.srs = srid
        else:
            raise TypeError('SRID must be set with an integer.')

    srid = property(_get_srid, _set_srid)

    # #### Output Methods ####
    def _geos_ptr(self):
        from django.contrib.gis.geos import GEOSGeometry
        return GEOSGeometry._from_wkb(self.wkb)

    @property
    def geos(self):
<<<<<<< HEAD
        "Return a GEOSGeometry object from this OGRGeometry."
=======
        "Returns a GEOSGeometry object from this OGRGeometry."
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        from django.contrib.gis.geos import GEOSGeometry
        return GEOSGeometry(self._geos_ptr(), self.srid)

    @property
    def gml(self):
<<<<<<< HEAD
        "Return the GML representation of the Geometry."
=======
        "Returns the GML representation of the Geometry."
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        return capi.to_gml(self.ptr)

    @property
    def hex(self):
<<<<<<< HEAD
        "Return the hexadecimal representation of the WKB (a string)."
=======
        "Returns the hexadecimal representation of the WKB (a string)."
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        return b2a_hex(self.wkb).upper()

    @property
    def json(self):
        """
<<<<<<< HEAD
        Return the GeoJSON representation of this Geometry.
=======
        Returns the GeoJSON representation of this Geometry.
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        """
        return capi.to_json(self.ptr)
    geojson = json

    @property
    def kml(self):
<<<<<<< HEAD
        "Return the KML representation of the Geometry."
=======
        "Returns the KML representation of the Geometry."
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        return capi.to_kml(self.ptr, None)

    @property
    def wkb_size(self):
<<<<<<< HEAD
        "Return the size of the WKB buffer."
=======
        "Returns the size of the WKB buffer."
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        return capi.get_wkbsize(self.ptr)

    @property
    def wkb(self):
<<<<<<< HEAD
        "Return the WKB representation of the Geometry."
=======
        "Returns the WKB representation of the Geometry."
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        if sys.byteorder == 'little':
            byteorder = 1  # wkbNDR (from ogr_core.h)
        else:
            byteorder = 0  # wkbXDR
        sz = self.wkb_size
        # Creating the unsigned character buffer, and passing it in by reference.
        buf = (c_ubyte * sz)()
        capi.to_wkb(self.ptr, byteorder, byref(buf))
        # Returning a buffer of the string at the pointer.
<<<<<<< HEAD
        return memoryview(string_at(buf, sz))

    @property
    def wkt(self):
        "Return the WKT representation of the Geometry."
=======
        return six.memoryview(string_at(buf, sz))

    @property
    def wkt(self):
        "Returns the WKT representation of the Geometry."
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        return capi.to_wkt(self.ptr, byref(c_char_p()))

    @property
    def ewkt(self):
<<<<<<< HEAD
        "Return the EWKT representation of the Geometry."
=======
        "Returns the EWKT representation of the Geometry."
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        srs = self.srs
        if srs and srs.srid:
            return 'SRID=%s;%s' % (srs.srid, self.wkt)
        else:
            return self.wkt

    # #### Geometry Methods ####
    def clone(self):
<<<<<<< HEAD
        "Clone this OGR Geometry."
=======
        "Clones this OGR Geometry."
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        return OGRGeometry(capi.clone_geom(self.ptr), self.srs)

    def close_rings(self):
        """
        If there are any rings within this geometry that have not been
        closed, this routine will do so by adding the starting point at the
        end.
        """
        # Closing the open rings.
        capi.geom_close_rings(self.ptr)

    def transform(self, coord_trans, clone=False):
        """
<<<<<<< HEAD
        Transform this geometry to a different spatial reference system.
        May take a CoordTransform object, a SpatialReference object, string
        WKT or PROJ.4, and/or an integer SRID.  By default, return nothing
        and transform the geometry in-place. However, if the `clone` keyword is
        set, return a transformed clone of this geometry.
=======
        Transforms this geometry to a different spatial reference system.
        May take a CoordTransform object, a SpatialReference object, string
        WKT or PROJ.4, and/or an integer SRID.  By default nothing is returned
        and the geometry is transformed in-place.  However, if the `clone`
        keyword is set, then a transformed clone of this geometry will be
        returned.
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        """
        if clone:
            klone = self.clone()
            klone.transform(coord_trans)
            return klone

        # Depending on the input type, use the appropriate OGR routine
        # to perform the transformation.
        if isinstance(coord_trans, CoordTransform):
            capi.geom_transform(self.ptr, coord_trans.ptr)
        elif isinstance(coord_trans, SpatialReference):
            capi.geom_transform_to(self.ptr, coord_trans.ptr)
<<<<<<< HEAD
        elif isinstance(coord_trans, (int, str)):
=======
        elif isinstance(coord_trans, six.integer_types + six.string_types):
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
            sr = SpatialReference(coord_trans)
            capi.geom_transform_to(self.ptr, sr.ptr)
        else:
            raise TypeError('Transform only accepts CoordTransform, '
                            'SpatialReference, string, and integer objects.')

    # #### Topology Methods ####
    def _topology(self, func, other):
        """A generalized function for topology operations, takes a GDAL function and
        the other geometry to perform the operation on."""
        if not isinstance(other, OGRGeometry):
            raise TypeError('Must use another OGRGeometry object for topology operations!')

        # Returning the output of the given function with the other geometry's
        # pointer.
        return func(self.ptr, other.ptr)

    def intersects(self, other):
<<<<<<< HEAD
        "Return True if this geometry intersects with the other."
        return self._topology(capi.ogr_intersects, other)

    def equals(self, other):
        "Return True if this geometry is equivalent to the other."
        return self._topology(capi.ogr_equals, other)

    def disjoint(self, other):
        "Return True if this geometry and the other are spatially disjoint."
        return self._topology(capi.ogr_disjoint, other)

    def touches(self, other):
        "Return True if this geometry touches the other."
        return self._topology(capi.ogr_touches, other)

    def crosses(self, other):
        "Return True if this geometry crosses the other."
        return self._topology(capi.ogr_crosses, other)

    def within(self, other):
        "Return True if this geometry is within the other."
        return self._topology(capi.ogr_within, other)

    def contains(self, other):
        "Return True if this geometry contains the other."
        return self._topology(capi.ogr_contains, other)

    def overlaps(self, other):
        "Return True if this geometry overlaps the other."
=======
        "Returns True if this geometry intersects with the other."
        return self._topology(capi.ogr_intersects, other)

    def equals(self, other):
        "Returns True if this geometry is equivalent to the other."
        return self._topology(capi.ogr_equals, other)

    def disjoint(self, other):
        "Returns True if this geometry and the other are spatially disjoint."
        return self._topology(capi.ogr_disjoint, other)

    def touches(self, other):
        "Returns True if this geometry touches the other."
        return self._topology(capi.ogr_touches, other)

    def crosses(self, other):
        "Returns True if this geometry crosses the other."
        return self._topology(capi.ogr_crosses, other)

    def within(self, other):
        "Returns True if this geometry is within the other."
        return self._topology(capi.ogr_within, other)

    def contains(self, other):
        "Returns True if this geometry contains the other."
        return self._topology(capi.ogr_contains, other)

    def overlaps(self, other):
        "Returns True if this geometry overlaps the other."
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        return self._topology(capi.ogr_overlaps, other)

    # #### Geometry-generation Methods ####
    def _geomgen(self, gen_func, other=None):
        "A helper routine for the OGR routines that generate geometries."
        if isinstance(other, OGRGeometry):
            return OGRGeometry(gen_func(self.ptr, other.ptr), self.srs)
        else:
            return OGRGeometry(gen_func(self.ptr), self.srs)

    @property
    def boundary(self):
<<<<<<< HEAD
        "Return the boundary of this geometry."
=======
        "Returns the boundary of this geometry."
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        return self._geomgen(capi.get_boundary)

    @property
    def convex_hull(self):
        """
<<<<<<< HEAD
        Return the smallest convex Polygon that contains all the points in
=======
        Returns the smallest convex Polygon that contains all the points in
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        this Geometry.
        """
        return self._geomgen(capi.geom_convex_hull)

    def difference(self, other):
        """
<<<<<<< HEAD
        Return a new geometry consisting of the region which is the difference
=======
        Returns a new geometry consisting of the region which is the difference
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        of this geometry and the other.
        """
        return self._geomgen(capi.geom_diff, other)

    def intersection(self, other):
        """
<<<<<<< HEAD
        Return a new geometry consisting of the region of intersection of this
=======
        Returns a new geometry consisting of the region of intersection of this
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        geometry and the other.
        """
        return self._geomgen(capi.geom_intersection, other)

    def sym_difference(self, other):
        """
<<<<<<< HEAD
        Return a new geometry which is the symmetric difference of this
=======
        Returns a new geometry which is the symmetric difference of this
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        geometry and the other.
        """
        return self._geomgen(capi.geom_sym_diff, other)

    def union(self, other):
        """
<<<<<<< HEAD
        Return a new geometry consisting of the region which is the union of
=======
        Returns a new geometry consisting of the region which is the union of
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        this geometry and the other.
        """
        return self._geomgen(capi.geom_union, other)


# The subclasses for OGR Geometry.
class Point(OGRGeometry):

    def _geos_ptr(self):
        from django.contrib.gis import geos
<<<<<<< HEAD
        return geos.Point._create_empty() if self.empty else super()._geos_ptr()
=======
        return geos.Point._create_empty() if self.empty else super(Point, self)._geos_ptr()
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61

    @classmethod
    def _create_empty(cls):
        return capi.create_geom(OGRGeomType('point').num)

    @property
    def x(self):
<<<<<<< HEAD
        "Return the X coordinate for this Point."
=======
        "Returns the X coordinate for this Point."
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        return capi.getx(self.ptr, 0)

    @property
    def y(self):
<<<<<<< HEAD
        "Return the Y coordinate for this Point."
=======
        "Returns the Y coordinate for this Point."
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        return capi.gety(self.ptr, 0)

    @property
    def z(self):
<<<<<<< HEAD
        "Return the Z coordinate for this Point."
=======
        "Returns the Z coordinate for this Point."
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        if self.coord_dim == 3:
            return capi.getz(self.ptr, 0)

    @property
    def tuple(self):
<<<<<<< HEAD
        "Return the tuple of this point."
=======
        "Returns the tuple of this point."
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        if self.coord_dim == 2:
            return (self.x, self.y)
        elif self.coord_dim == 3:
            return (self.x, self.y, self.z)
    coords = tuple


class LineString(OGRGeometry):

    def __getitem__(self, index):
<<<<<<< HEAD
        "Return the Point at the given index."
        if 0 <= index < self.point_count:
=======
        "Returns the Point at the given index."
        if index >= 0 and index < self.point_count:
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
            x, y, z = c_double(), c_double(), c_double()
            capi.get_point(self.ptr, index, byref(x), byref(y), byref(z))
            dim = self.coord_dim
            if dim == 1:
                return (x.value,)
            elif dim == 2:
                return (x.value, y.value)
            elif dim == 3:
                return (x.value, y.value, z.value)
        else:
<<<<<<< HEAD
            raise IndexError('Index out of range when accessing points of a line string: %s.' % index)

    def __len__(self):
        "Return the number of points in the LineString."
=======
            raise OGRIndexError('index out of range: %s' % str(index))

    def __iter__(self):
        "Iterates over each point in the LineString."
        for i in range(self.point_count):
            yield self[i]

    def __len__(self):
        "The length returns the number of points in the LineString."
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        return self.point_count

    @property
    def tuple(self):
<<<<<<< HEAD
        "Return the tuple representation of this LineString."
=======
        "Returns the tuple representation of this LineString."
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        return tuple(self[i] for i in range(len(self)))
    coords = tuple

    def _listarr(self, func):
        """
        Internal routine that returns a sequence (list) corresponding with
        the given function.
        """
        return [func(self.ptr, i) for i in range(len(self))]

    @property
    def x(self):
<<<<<<< HEAD
        "Return the X coordinates in a list."
=======
        "Returns the X coordinates in a list."
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        return self._listarr(capi.getx)

    @property
    def y(self):
<<<<<<< HEAD
        "Return the Y coordinates in a list."
=======
        "Returns the Y coordinates in a list."
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        return self._listarr(capi.gety)

    @property
    def z(self):
<<<<<<< HEAD
        "Return the Z coordinates in a list."
=======
        "Returns the Z coordinates in a list."
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        if self.coord_dim == 3:
            return self._listarr(capi.getz)


# LinearRings are used in Polygons.
class LinearRing(LineString):
    pass


class Polygon(OGRGeometry):

    def __len__(self):
<<<<<<< HEAD
        "Return the number of interior rings in this Polygon."
        return self.geom_count

    def __getitem__(self, index):
        "Get the ring at the specified index."
        if 0 <= index < self.geom_count:
            return OGRGeometry(capi.clone_geom(capi.get_geom_ref(self.ptr, index)), self.srs)
        else:
            raise IndexError('Index out of range when accessing rings of a polygon: %s.' % index)
=======
        "The number of interior rings in this Polygon."
        return self.geom_count

    def __iter__(self):
        "Iterates through each ring in the Polygon."
        for i in range(self.geom_count):
            yield self[i]

    def __getitem__(self, index):
        "Gets the ring at the specified index."
        if index < 0 or index >= self.geom_count:
            raise OGRIndexError('index out of range: %s' % index)
        else:
            return OGRGeometry(capi.clone_geom(capi.get_geom_ref(self.ptr, index)), self.srs)
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61

    # Polygon Properties
    @property
    def shell(self):
<<<<<<< HEAD
        "Return the shell of this Polygon."
=======
        "Returns the shell of this Polygon."
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        return self[0]  # First ring is the shell
    exterior_ring = shell

    @property
    def tuple(self):
<<<<<<< HEAD
        "Return a tuple of LinearRing coordinate tuples."
=======
        "Returns a tuple of LinearRing coordinate tuples."
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        return tuple(self[i].tuple for i in range(self.geom_count))
    coords = tuple

    @property
    def point_count(self):
<<<<<<< HEAD
        "Return the number of Points in this Polygon."
=======
        "The number of Points in this Polygon."
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        # Summing up the number of points in each ring of the Polygon.
        return sum(self[i].point_count for i in range(self.geom_count))

    @property
    def centroid(self):
<<<<<<< HEAD
        "Return the centroid (a Point) of this Polygon."
=======
        "Returns the centroid (a Point) of this Polygon."
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        # The centroid is a Point, create a geometry for this.
        p = OGRGeometry(OGRGeomType('Point'))
        capi.get_centroid(self.ptr, p.ptr)
        return p


# Geometry Collection base class.
class GeometryCollection(OGRGeometry):
    "The Geometry Collection class."

    def __getitem__(self, index):
<<<<<<< HEAD
        "Get the Geometry at the specified index."
        if 0 <= index < self.geom_count:
            return OGRGeometry(capi.clone_geom(capi.get_geom_ref(self.ptr, index)), self.srs)
        else:
            raise IndexError('Index out of range when accessing geometry in a collection: %s.' % index)

    def __len__(self):
        "Return the number of geometries in this Geometry Collection."
=======
        "Gets the Geometry at the specified index."
        if index < 0 or index >= self.geom_count:
            raise OGRIndexError('index out of range: %s' % index)
        else:
            return OGRGeometry(capi.clone_geom(capi.get_geom_ref(self.ptr, index)), self.srs)

    def __iter__(self):
        "Iterates over each Geometry."
        for i in range(self.geom_count):
            yield self[i]

    def __len__(self):
        "The number of geometries in this Geometry Collection."
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        return self.geom_count

    def add(self, geom):
        "Add the geometry to this Geometry Collection."
        if isinstance(geom, OGRGeometry):
            if isinstance(geom, self.__class__):
                for g in geom:
                    capi.add_geom(self.ptr, g.ptr)
            else:
                capi.add_geom(self.ptr, geom.ptr)
<<<<<<< HEAD
        elif isinstance(geom, str):
=======
        elif isinstance(geom, six.string_types):
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
            tmp = OGRGeometry(geom)
            capi.add_geom(self.ptr, tmp.ptr)
        else:
            raise GDALException('Must add an OGRGeometry.')

    @property
    def point_count(self):
<<<<<<< HEAD
        "Return the number of Points in this Geometry Collection."
=======
        "The number of Points in this Geometry Collection."
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        # Summing up the number of points in each geometry in this collection
        return sum(self[i].point_count for i in range(self.geom_count))

    @property
    def tuple(self):
<<<<<<< HEAD
        "Return a tuple representation of this Geometry Collection."
=======
        "Returns a tuple representation of this Geometry Collection."
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        return tuple(self[i].tuple for i in range(self.geom_count))
    coords = tuple


# Multiple Geometry types.
class MultiPoint(GeometryCollection):
    pass


class MultiLineString(GeometryCollection):
    pass


class MultiPolygon(GeometryCollection):
    pass


# Class mapping dictionary (using the OGRwkbGeometryType as the key)
GEO_CLASSES = {1: Point,
               2: LineString,
               3: Polygon,
               4: MultiPoint,
               5: MultiLineString,
               6: MultiPolygon,
               7: GeometryCollection,
               101: LinearRing,
               1 + OGRGeomType.wkb25bit: Point,
               2 + OGRGeomType.wkb25bit: LineString,
               3 + OGRGeomType.wkb25bit: Polygon,
               4 + OGRGeomType.wkb25bit: MultiPoint,
               5 + OGRGeomType.wkb25bit: MultiLineString,
               6 + OGRGeomType.wkb25bit: MultiPolygon,
               7 + OGRGeomType.wkb25bit: GeometryCollection,
               }
