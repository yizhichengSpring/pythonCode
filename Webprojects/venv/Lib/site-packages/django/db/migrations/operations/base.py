<<<<<<< HEAD
from django.db import router


class Operation:
=======
from __future__ import unicode_literals

from django.db import router


class Operation(object):
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
    """
    Base class for migration operations.

    It's responsible for both mutating the in-memory model state
    (see db/migrations/state.py) to represent what it performs, as well
    as actually performing it against a live database.

    Note that some operations won't modify memory state at all (e.g. data
    copying operations), and some will need their modifications to be
    optionally specified by the user (e.g. custom Python code snippets)

    Due to the way this class deals with deconstruction, it should be
    considered immutable.
    """

    # If this migration can be run in reverse.
    # Some operations are impossible to reverse, like deleting data.
    reversible = True

    # Can this migration be represented as SQL? (things like RunPython cannot)
    reduces_to_sql = True

    # Should this operation be forced as atomic even on backends with no
    # DDL transaction support (i.e., does it have no DDL, like RunPython)
    atomic = False

    # Should this operation be considered safe to elide and optimize across?
    elidable = False

    serialization_expand_args = []

    def __new__(cls, *args, **kwargs):
        # We capture the arguments to make returning them trivial
        self = object.__new__(cls)
        self._constructor_args = (args, kwargs)
        return self

    def deconstruct(self):
        """
<<<<<<< HEAD
        Return a 3-tuple of class import path (or just name if it lives
=======
        Returns a 3-tuple of class import path (or just name if it lives
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        under django.db.migrations), positional arguments, and keyword
        arguments.
        """
        return (
            self.__class__.__name__,
            self._constructor_args[0],
            self._constructor_args[1],
        )

    def state_forwards(self, app_label, state):
        """
<<<<<<< HEAD
        Take the state from the previous migration, and mutate it
=======
        Takes the state from the previous migration, and mutates it
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        so that it matches what this migration would perform.
        """
        raise NotImplementedError('subclasses of Operation must provide a state_forwards() method')

    def database_forwards(self, app_label, schema_editor, from_state, to_state):
        """
<<<<<<< HEAD
        Perform the mutation on the database schema in the normal
=======
        Performs the mutation on the database schema in the normal
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        (forwards) direction.
        """
        raise NotImplementedError('subclasses of Operation must provide a database_forwards() method')

    def database_backwards(self, app_label, schema_editor, from_state, to_state):
        """
<<<<<<< HEAD
        Perform the mutation on the database schema in the reverse
=======
        Performs the mutation on the database schema in the reverse
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        direction - e.g. if this were CreateModel, it would in fact
        drop the model's table.
        """
        raise NotImplementedError('subclasses of Operation must provide a database_backwards() method')

    def describe(self):
        """
<<<<<<< HEAD
        Output a brief summary of what the action does.
=======
        Outputs a brief summary of what the action does.
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        """
        return "%s: %s" % (self.__class__.__name__, self._constructor_args)

    def references_model(self, name, app_label=None):
        """
<<<<<<< HEAD
        Return True if there is a chance this operation references the given
=======
        Returns True if there is a chance this operation references the given
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        model name (as a string), with an optional app label for accuracy.

        Used for optimization. If in doubt, return True;
        returning a false positive will merely make the optimizer a little
        less efficient, while returning a false negative may result in an
        unusable optimized migration.
        """
        return True

    def references_field(self, model_name, name, app_label=None):
        """
<<<<<<< HEAD
        Return True if there is a chance this operation references the given
=======
        Returns True if there is a chance this operation references the given
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        field name, with an optional app label for accuracy.

        Used for optimization. If in doubt, return True.
        """
        return self.references_model(model_name, app_label)

    def allow_migrate_model(self, connection_alias, model):
        """
<<<<<<< HEAD
        Return wether or not a model may be migrated.
=======
        Returns if we're allowed to migrate the model.
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61

        This is a thin wrapper around router.allow_migrate_model() that
        preemptively rejects any proxy, swapped out, or unmanaged model.
        """
        if not model._meta.can_migrate(connection_alias):
            return False

        return router.allow_migrate_model(connection_alias, model)

    def reduce(self, operation, in_between, app_label=None):
        """
        Return either a list of operations the actual operation should be
        replaced with or a boolean that indicates whether or not the specified
        operation can be optimized across.
        """
        if self.elidable:
            return [operation]
        elif operation.elidable:
            return [self]
        return False

    def __repr__(self):
        return "<%s %s%s>" % (
            self.__class__.__name__,
            ", ".join(map(repr, self._constructor_args[0])),
            ",".join(" %s=%r" % x for x in self._constructor_args[1].items()),
        )
