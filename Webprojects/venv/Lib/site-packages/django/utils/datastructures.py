import copy
from collections import OrderedDict

<<<<<<< HEAD

class OrderedSet:
=======
from django.utils import six


class OrderedSet(object):
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
    """
    A set which keeps the ordering of the inserted items.
    Currently backs onto OrderedDict.
    """

    def __init__(self, iterable=None):
<<<<<<< HEAD
        self.dict = OrderedDict.fromkeys(iterable or ())
=======
        self.dict = OrderedDict(((x, None) for x in iterable) if iterable else [])
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61

    def add(self, item):
        self.dict[item] = None

    def remove(self, item):
        del self.dict[item]

    def discard(self, item):
        try:
            self.remove(item)
        except KeyError:
            pass

    def __iter__(self):
<<<<<<< HEAD
        return iter(self.dict)
=======
        return iter(self.dict.keys())
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61

    def __contains__(self, item):
        return item in self.dict

    def __bool__(self):
        return bool(self.dict)

<<<<<<< HEAD
=======
    def __nonzero__(self):      # Python 2 compatibility
        return type(self).__bool__(self)

>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
    def __len__(self):
        return len(self.dict)


class MultiValueDictKeyError(KeyError):
    pass


class MultiValueDict(dict):
    """
    A subclass of dictionary customized to handle multiple values for the
    same key.

    >>> d = MultiValueDict({'name': ['Adrian', 'Simon'], 'position': ['Developer']})
    >>> d['name']
    'Simon'
    >>> d.getlist('name')
    ['Adrian', 'Simon']
    >>> d.getlist('doesnotexist')
    []
    >>> d.getlist('doesnotexist', ['Adrian', 'Simon'])
    ['Adrian', 'Simon']
    >>> d.get('lastname', 'nonexistent')
    'nonexistent'
    >>> d.setlist('lastname', ['Holovaty', 'Willison'])

    This class exists to solve the irritating problem raised by cgi.parse_qs,
    which returns a list for every key, even though most Web forms submit
    single name-value pairs.
    """
    def __init__(self, key_to_list_mapping=()):
<<<<<<< HEAD
        super().__init__(key_to_list_mapping)

    def __repr__(self):
        return "<%s: %s>" % (self.__class__.__name__, super().__repr__())

    def __getitem__(self, key):
        """
        Return the last data value for this key, or [] if it's an empty list;
        raise KeyError if not found.
        """
        try:
            list_ = super().__getitem__(key)
        except KeyError:
            raise MultiValueDictKeyError(key)
=======
        super(MultiValueDict, self).__init__(key_to_list_mapping)

    def __repr__(self):
        return "<%s: %s>" % (self.__class__.__name__,
                             super(MultiValueDict, self).__repr__())

    def __getitem__(self, key):
        """
        Returns the last data value for this key, or [] if it's an empty list;
        raises KeyError if not found.
        """
        try:
            list_ = super(MultiValueDict, self).__getitem__(key)
        except KeyError:
            raise MultiValueDictKeyError(repr(key))
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        try:
            return list_[-1]
        except IndexError:
            return []

    def __setitem__(self, key, value):
<<<<<<< HEAD
        super().__setitem__(key, [value])
=======
        super(MultiValueDict, self).__setitem__(key, [value])
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61

    def __copy__(self):
        return self.__class__([
            (k, v[:])
            for k, v in self.lists()
        ])

<<<<<<< HEAD
    def __deepcopy__(self, memo):
=======
    def __deepcopy__(self, memo=None):
        if memo is None:
            memo = {}
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        result = self.__class__()
        memo[id(self)] = result
        for key, value in dict.items(self):
            dict.__setitem__(result, copy.deepcopy(key, memo),
                             copy.deepcopy(value, memo))
        return result

    def __getstate__(self):
        obj_dict = self.__dict__.copy()
        obj_dict['_data'] = {k: self._getlist(k) for k in self}
        return obj_dict

    def __setstate__(self, obj_dict):
        data = obj_dict.pop('_data', {})
        for k, v in data.items():
            self.setlist(k, v)
        self.__dict__.update(obj_dict)

    def get(self, key, default=None):
        """
<<<<<<< HEAD
        Return the last data value for the passed key. If key doesn't exist
        or value is an empty list, return `default`.
=======
        Returns the last data value for the passed key. If key doesn't exist
        or value is an empty list, then default is returned.
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        """
        try:
            val = self[key]
        except KeyError:
            return default
        if val == []:
            return default
        return val

    def _getlist(self, key, default=None, force_list=False):
        """
        Return a list of values for the key.

        Used internally to manipulate values list. If force_list is True,
        return a new copy of values.
        """
        try:
<<<<<<< HEAD
            values = super().__getitem__(key)
=======
            values = super(MultiValueDict, self).__getitem__(key)
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        except KeyError:
            if default is None:
                return []
            return default
        else:
            if force_list:
                values = list(values) if values is not None else None
            return values

    def getlist(self, key, default=None):
        """
        Return the list of values for the key. If key doesn't exist, return a
        default value.
        """
        return self._getlist(key, default, force_list=True)

    def setlist(self, key, list_):
<<<<<<< HEAD
        super().__setitem__(key, list_)
=======
        super(MultiValueDict, self).__setitem__(key, list_)
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61

    def setdefault(self, key, default=None):
        if key not in self:
            self[key] = default
            # Do not return default here because __setitem__() may store
            # another value -- QueryDict.__setitem__() does. Look it up.
        return self[key]

    def setlistdefault(self, key, default_list=None):
        if key not in self:
            if default_list is None:
                default_list = []
            self.setlist(key, default_list)
            # Do not return default_list here because setlist() may store
            # another value -- QueryDict.setlist() does. Look it up.
        return self._getlist(key)

    def appendlist(self, key, value):
<<<<<<< HEAD
        """Append an item to the internal list associated with key."""
        self.setlistdefault(key).append(value)

    def items(self):
        """
        Yield (key, value) pairs, where value is the last item in the list
=======
        """Appends an item to the internal list associated with key."""
        self.setlistdefault(key).append(value)

    def _iteritems(self):
        """
        Yields (key, value) pairs, where value is the last item in the list
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        associated with the key.
        """
        for key in self:
            yield key, self[key]

<<<<<<< HEAD
    def lists(self):
        """Yield (key, list) pairs."""
        return iter(super().items())

    def values(self):
=======
    def _iterlists(self):
        """Yields (key, list) pairs."""
        return six.iteritems(super(MultiValueDict, self))

    def _itervalues(self):
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        """Yield the last value on every key list."""
        for key in self:
            yield self[key]

<<<<<<< HEAD
    def copy(self):
        """Return a shallow copy of this object."""
        return copy.copy(self)

    def update(self, *args, **kwargs):
        """Extend rather than replace existing key lists."""
=======
    if six.PY3:
        items = _iteritems
        lists = _iterlists
        values = _itervalues
    else:
        iteritems = _iteritems
        iterlists = _iterlists
        itervalues = _itervalues

        def items(self):
            return list(self.iteritems())

        def lists(self):
            return list(self.iterlists())

        def values(self):
            return list(self.itervalues())

    def copy(self):
        """Returns a shallow copy of this object."""
        return copy.copy(self)

    def update(self, *args, **kwargs):
        """
        update() extends rather than replaces existing key lists.
        Also accepts keyword args.
        """
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        if len(args) > 1:
            raise TypeError("update expected at most 1 arguments, got %d" % len(args))
        if args:
            other_dict = args[0]
            if isinstance(other_dict, MultiValueDict):
                for key, value_list in other_dict.lists():
                    self.setlistdefault(key).extend(value_list)
            else:
                try:
                    for key, value in other_dict.items():
                        self.setlistdefault(key).append(value)
                except TypeError:
                    raise ValueError("MultiValueDict.update() takes either a MultiValueDict or dictionary")
<<<<<<< HEAD
        for key, value in kwargs.items():
            self.setlistdefault(key).append(value)

    def dict(self):
        """Return current object as a dict with singular values."""
=======
        for key, value in six.iteritems(kwargs):
            self.setlistdefault(key).append(value)

    def dict(self):
        """
        Returns current object as a dict with singular values.
        """
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        return {key: self[key] for key in self}


class ImmutableList(tuple):
    """
    A tuple-like object that raises useful errors when it is asked to mutate.

    Example::

        >>> a = ImmutableList(range(5), warning="You cannot mutate this.")
        >>> a[3] = '4'
        Traceback (most recent call last):
            ...
        AttributeError: You cannot mutate this.
    """

<<<<<<< HEAD
    def __new__(cls, *args, warning='ImmutableList object is immutable.', **kwargs):
=======
    def __new__(cls, *args, **kwargs):
        if 'warning' in kwargs:
            warning = kwargs['warning']
            del kwargs['warning']
        else:
            warning = 'ImmutableList object is immutable.'
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        self = tuple.__new__(cls, *args, **kwargs)
        self.warning = warning
        return self

    def complain(self, *wargs, **kwargs):
        if isinstance(self.warning, Exception):
            raise self.warning
        else:
            raise AttributeError(self.warning)

    # All list mutation functions complain.
    __delitem__ = complain
    __delslice__ = complain
    __iadd__ = complain
    __imul__ = complain
    __setitem__ = complain
    __setslice__ = complain
    append = complain
    extend = complain
    insert = complain
    pop = complain
    remove = complain
    sort = complain
    reverse = complain


class DictWrapper(dict):
    """
<<<<<<< HEAD
    Wrap accesses to a dictionary so that certain values (those starting with
=======
    Wraps accesses to a dictionary so that certain values (those starting with
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
    the specified prefix) are passed through a function before being returned.
    The prefix is removed before looking up the real value.

    Used by the SQL construction code to ensure that values are correctly
    quoted before being used.
    """
    def __init__(self, data, func, prefix):
<<<<<<< HEAD
        super().__init__(data)
=======
        super(DictWrapper, self).__init__(data)
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        self.func = func
        self.prefix = prefix

    def __getitem__(self, key):
        """
<<<<<<< HEAD
        Retrieve the real value after stripping the prefix string (if
=======
        Retrieves the real value after stripping the prefix string (if
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        present). If the prefix is present, pass the value through self.func
        before returning, otherwise return the raw value.
        """
        if key.startswith(self.prefix):
            use_func = True
            key = key[len(self.prefix):]
        else:
            use_func = False
<<<<<<< HEAD
        value = super().__getitem__(key)
=======
        value = super(DictWrapper, self).__getitem__(key)
>>>>>>> b6c47195d68bf438d50153265b824fab6e10db61
        if use_func:
            return self.func(value)
        return value
